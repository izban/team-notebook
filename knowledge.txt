dbl Simpson() { return (F(-1) + 4 * F(0) + F(1)) / 6; }
dbl Runge2() { return (F(-sqrtl(1.0 / 3)) + F(sqrtl(1.0 / 3))) / 2; }
dbl Runge3() { return (F(-sqrtl(3.0 / 5)) * 5 + F(0) * 8 + F(sqrtl(3.0 / 5)) * 5) / 18; }

Simpson и Runge2 -- точны для полиномов степени <= 3
Runge3 -- точен для полиномов степени <= 5


Явный Рунге-Кутт четвертого порядка, ошибка O(h^4)

y' = f(x, y)
y_(n+1) = y_n + (k1 + 2 * k2 + 2 * k3 + k4) * h / 6

k1 = f(xn, yn)
k2 = f(xn + h/2, yn + h/2 * k1)
k3 = f(xn + h/2, yn + h/2 * k2)
k4 = f(xn + h, yn + h * k3)

Методы Адамса-Башфорта

y_n+3 = y_n+2 + h * (23/12 * f(x_n+2,y_n+2) - 4/3 * f(x_n+1,y_n+1) + 5/12 * f(x_n,y_n))
y_n+4 = y_n+3 + h * (55/24 * f(x_n+3,y_n+3) - 59/24 * f(x_n+2,y_n+2) + 37/24 * f(x_n+1,y_n+1) - 3/8 * f(x_n,y_n))
y_n+5 = y_n+4 + h * (1901/720 * f(x_n+4,y_n+4) - 1387/360 * f(x_n+3,y_n+3)
    + 109/30 * f(x_n+2,y_n+2) - 637/360 * f(x_n+1,y_n+1) + 251/720 * f(x_n,y_n))

Извлечение корня по простому модулю (от Сережи)
3 <= p, 1 <= a < p, найти x^2 = a

1) Если a^((p - 1)/2) != 1, return -1
2) Выбрать случайный 1 <= i < p
3) T(x) = (x + i)^((p - 1)/2) mod (x^2 - a) = bx + c
4) Если b != 0 то вернуть с/b, иначе к шагу 2)


Иногда вместо того чтобы считать первообразный у простого числа,
можно написать чекер ответа и перебирать случайный первообразный.

Не заходит FFT по TL-ю -- чекнуть что стоит double, а не long double

mt19937 генерит случайный unsigned int, если хочется больше есть mt19937_64

Иногда можно представить ответ в виде многочлена и вместо подсчета самих к-тов посчитать значения и проинтерполировать

Лемма Бернсайда:

Группа G действует на множество X
Тогда число классов эквивалентности = (sum |f(g)| for g in G) / |G|
где f(g) = число x (из X) : g(x) == x

